MoonBitにおけるコメント保持型JSONC-YAML相互変換ライブラリのアーキテクチャ設計と実装戦略1. エグゼクティブサマリー現代のソフトウェア開発において、設定ファイル（Configuration Files）とデータ交換フォーマットは、システムの動作を定義する血流のような役割を果たしています。特にJSON (JavaScript Object Notation) と YAML (YAML Ain't Markup Language) は、クラウドネイティブな環境やDevOpsの文脈において支配的な地位を確立しています。しかし、これら二つのフォーマット間での変換プロセスには、長年にわたる未解決の課題が存在します。それは、「コメントとフォーマット（Trivia）」の消失です。標準的なJSONは仕様上コメントをサポートしておらず、開発者はコメントを記述するためにJSONC (JSON with Comments) などの拡張仕様や、VS Codeなどのエディタによる暗黙のサポートに依存しています 1。一方、YAMLは人間による可読性を最優先に設計されており、コメント、アンカー、エイリアスといった豊富な機能を備えています 3。構成管理ツール（IaC）やアプリケーション設定において、これらのフォーマットを相互に変換する需要は極めて高いものの、既存の多くのパーサーやコンバーターは、構文解析の過程でコメントや空白を「意味のないトークン（Trivia）」として破棄してしまいます 5。本レポートは、WebAssemblyに最適化された次世代プログラミング言語であるMoonBitを用いて、JSONCとYAML間でコメントや空白情報を完全に保持したまま相互変換を行うライブラリ（以下、moon-convertと仮称）の設計と実装戦略を包括的に提案するものです。MoonBitが持つ強力な代数的データ型（ADT）、パターンマッチング、そして高い実行効率は、テキスト処理とコンパイラ作成において卓越した適性を持っています 6。本稿では、抽象構文木（AST）ではなく具象構文木（CST: Concrete Syntax Tree） を中心に据えたアーキテクチャを採用し、RustのrowanやGoのyaml.Node、Prettierのプリンターアルゴリズムなどの先行研究を分析・統合することで、実用的かつ高信頼な変換エンジンの構築指針を示します。2. 理論的背景：ロスレス構文解析の課題と解決策プログラミング言語やデータ記述言語の処理系において、ソースコードを計算機が理解可能な構造へと変換するプロセスは一般的に「解析（Parsing）」と呼ばれます。しかし、通常の解析と「コメントを保持する解析」の間には、埋めがたい理論的・実装的な乖離が存在します。2.1 抽象構文木（AST）と具象構文木（CST）の決定的な違い一般的なコンパイラやシリアライザ（例：Rustのserde_jsonなど）は、ソースコードから抽象構文木（AST） を生成します 8。ASTは、プログラムの「意味（Semantics）」のみを抽出したツリー構造です。例えば、以下のJSONCコードを考えます。コード スニペット{
  "timeout": 5000 // ミリ秒単位
}
ASTパーサーはこれを「キーtimeoutと値5000を持つオブジェクト」として解釈します。この過程で、// ミリ秒単位というコメントや、キーと値の間のスペース、改行などは「意味がない」として捨てられます。これをYAMLに変換すると以下のようになります。YAMLtimeout: 5000
データとしては等価ですが、開発者が残した「ミリ秒単位」という重要なコンテキスト情報は永遠に失われます。これに対し、具象構文木（CST） はソースコードのあらゆる情報を「ロスレス（Lossless）」に保持します 10。CSTにおいては、コメント、空白、カンマ、括弧といったトークンもすべてノードとしてツリーに組み込まれます。Rustのエコシステムにおけるrust-analyzerで使用されているrowanライブラリなどは、このCSTアプローチ（Red-Green Treeモデル）を採用することで、リファクタリングツールやフォーマッターの実装を可能にしています 10。MoonBitでコンバーターを実装する場合、ASTではなくCST、あるいはCSTに準じた「トリビア（Trivia）付きAST」を設計の中心に据える必要があります。2.2 トリビア結合問題（The Trivia Attachment Problem）コメント保持における最大のアルゴリズム的課題は、「コメントをどのノードに所属させるか」という結合（Attachment） の問題です 13。ソースコード上のコメントは、単なる文字の羅列であり、本来どのデータノードにも属していません。以下の例を見てみましょう。コード スニペット// サーバー設定
{
  "host": "localhost", // デフォルトホスト
  /* ポート番号 */ "port": 8080
}
ここで、パーサーは以下の判断を迫られます。// サーバー設定 はルートオブジェクトに対する先行コメント（Leading Comment） か？// デフォルトホスト は "host": "localhost" ペアに対する後置コメント（Trailing Comment） か？/* ポート番号 */ は "port" キーに対する先行コメントか？Prettierなどのコードフォーマッターは、各ノードの開始・終了位置（Span/Range）とコメントの位置情報を比較し、ヒューリスティックなアルゴリズムを用いてコメントを最も適切なノードに「アタッチ」します 15。本ライブラリの設計においても、このアタッチメント戦略の実装が品質を左右する鍵となります。3. MoonBitプラットフォームの特性と適合性分析MoonBitは、クラウドおよびエッジコンピューティング向けに設計されたRustライクな構文を持つ静的型付け言語です 6。本プロジェクトにおいてMoonBitを採用する利点は、その言語機能とランタイム特性に深く根差しています。3.1 代数的データ型（ADT）とパターンマッチングによる木構造の表現JSONやYAMLのような再帰的な木構造データを扱う際、MoonBitの代数的データ型（ADT） は極めて強力な表現力を提供します 17。JavaやGoのような言語では、異なる種類のノードを表現するためにインターフェースや構造体の埋め込みを駆使する必要がありますが、MoonBitではenumを用いて簡潔かつ厳密に定義できます。コード スニペットenum JsonNode {
  JString(String, Trivia)
  JNumber(Double, Trivia)
  JObject(Map, Trivia)
  //...
}
このように、各バリアントにTrivia（コメント情報）を持たせる設計が自然に行えます。また、パターンマッチングを用いることで、ノードの種類に応じた処理（例：文字列ならクォート処理、オブジェクトなら再帰処理）を、コンパイラによる網羅性チェックの恩恵を受けながら安全に記述できます 19。これは、複雑な入れ子構造を持つJSON/YAMLの変換ロジックにおけるバグの混入を劇的に低減します。3.2 文字列処理性能とWasm最適化変換ライブラリは大量の文字列操作を伴います。MoonBitのString型はUTF-16エンコーディングを採用しており、ブラウザ環境（JavaScript）との相互運用性が高く設計されています 21。また、頻繁な文字列連結によるパフォーマンス低下を防ぐために、標準ライブラリで提供されているStringBuilderを活用することで、線形時間での文字列構築が可能です 22。既存の研究によれば、単純な文字列連結（+演算子）は二次関数的なパフォーマンス劣化を招く可能性がありますが 23、MoonBitの最適化されたツールチェーンは、特にWebAssemblyターゲットにおいて極めて小さなバイナリサイズと高速な実行速度を実現します 24。これは、ブラウザ上で動作する設定ファイル変換ツールや、CI/CDパイプライン上で動作するCLIツールとして配布する際に大きなアドバンテージとなります。3.3 エコシステムと既存資産の現状MoonBitのエコシステムは急速に成長していますが、現状ではJSONCやYAMLの「コメント保持パーサー」は標準ライブラリには存在しません。標準のmoonbitlang/core/jsonは存在しますが、これはデータ変換（AST）に特化しています 26。また、実験的なmoonbitlang/parserはMoonBit言語自体のパーサーであり、汎用的なフォーマット変換には直接転用できません 27。したがって、本ライブラリの開発は、既存のパーサーをラップするのではなく、字句解析器（Lexer）と構文解析器（Parser）をスクラッチで実装する必要があります。これは高い工数を要しますが、逆に言えば、MoonBitの言語機能に完全に最適化された、依存関係のない軽量なライブラリを構築する好機でもあります。4. moon-convert アーキテクチャ設計本ライブラリmoon-convertのアーキテクチャは、典型的なコンパイラのフロントエンド構成を踏襲しつつ、相互変換のために双方向性を意識した設計とします。4.1 全体パイプラインデータフローは以下の4段階で構成されます。段階コンポーネント入力出力役割1Lexer (Tokenizer)Raw Source Code (String)Token Stream文字列をトークン列（意味語＋トリビア）に分解する。2CST ParserToken StreamCST (Concrete Syntax Tree)トークンを階層構造に組み上げ、コメントをノードに結合する。3TransformerCST (Source Format)CST (Target Format)JSONCの構造をYAMLの構造へ（またはその逆）変換する。4Pretty PrinterCST (Target Format)Formatted Stringインデントや改行を計算し、最終的な文字列を出力する。4.2 データ構造設計：トリビアを含むノード最も重要な設計決定は、CSTノードの定義です。コメントや空白を保持するために、すべての意味的ノードにTrivia情報を付与します。MoonBitによるデータ構造定義案:コード スニペット// コメントの種類
enum CommentKind {
  LineComment  // //... または #...
  BlockComment // /*... */
}

// コメントトークン
struct Comment {
  content : String
  kind : CommentKind
  preceding_newline : Bool // 直前に改行があったか
}

// トリビア（ノードに付随する付加情報）
struct Trivia {
  leading : Array[Comment]  // ノードの前に存在するコメント
  trailing : Array[Comment] // ノードの直後（同一行）に存在するコメント
}

// JSONCの具象構文木ノード
enum JsonNode {
  JNull(Trivia)
  JBool(Bool, Trivia)
  JNumber(String, Trivia) // 数値は精度維持のため文字列として保持推奨
  JString(String, Trivia)
  JArray(Array[JsonNode], Trivia)
  JObject(Array[JProperty], Trivia)
}

// オブジェクトのプロパティ
struct JProperty {
  key : String
  value : JsonNode
  key_trivia : Trivia // キーに付随するコメント
}
この構造により、例えば /* A */ "key": /* B */ "value" // C というJSONCの断片は、JPropertyとして表現され、key_triviaにコメントA、valueのTriviaにコメントB（leading）とC（trailing）が格納されることになります。5. 実装詳細：字句解析と構文解析5.1 字句解析器（Lexer）の実装Lexerは入力文字列を走査し、トークンを生成します。ここで重要なのは、コメントと空白を捨てずにトークン化することです。通常のコンパイラではこれらをスキップしますが、本ライブラリではTokenKind::CommentやTokenKind::Whitespaceとして明確に扱います。MoonBitの文字列操作において、code_unit_at(index)メソッドを使用することで、UTF-16コードユニット単位での高速なスキャンが可能です 28。Lexerの状態管理:JSONCとYAMLでは字句規則が異なります。JSONC: ブロックコメント /* */ と行コメント // の両方をサポート。文字列中のエスケープシーケンス \n, \t などの処理が必要。YAML: 行コメント # のみ。ただし、インデント（スペースの数）が構文上の意味を持つため、LexerまたはParser側でインデントレベルを追跡するロジックが必要になります。5.2 構文解析器（Parser）とトリビア結合アルゴリズムParserはトークン列を読み込み、CSTを構築します。ここで前述の「トリビア結合問題」を解決するアルゴリズムを実装します。提案する結合アルゴリズム（Leading/Trailing Heuristic）:Pending Trivia Buffer: パーサーは「まだどのノードにも属していないコメント」を一時的に保持するバッファを持ちます。ノード開始時: 新しいノード（例：オブジェクトの開始 { や 文字列リテラル）の解析を開始する直前に、バッファ内のコメントを全て取り出し、そのノードのLeading Triviaとして割り当てます。ノード終了時: ノードの解析が完了した直後、次のトークンを確認します。もし次のトークンが「同じ行にあるコメント」であれば、それを消費してそのノードのTrailing Triviaとして割り当てます。改行が見つかった時点でTrailingの判定は終了します。このアルゴリズムは、Prettierなどが採用している手法に近く、直感的で実装が比較的容易です 15。コード スニペット// 擬似コード的なMoonBit実装イメージ
fn parse_node(self : Parser) -> JsonNode {
  // 1. バッファにあるコメントを Leading Trivia とする
  let leading = self.flush_pending_trivia()
  
  // 2. 本体を解析
  let node = match self.peek() {
    LBrace => self.parse_object(leading)
    LBracket => self.parse_array(leading)
    StringLit(s) => { self.bump(); JString(s, Trivia::{ leading, trailing: }) }
    //...
  }

  // 3. 直後のコメントを Trailing Trivia として取得
  if self.is_trailing_comment_available() {
    let trailing = self.consume_trailing_comment()
    node.add_trailing(trailing)
  }
  
  node
}
6. 変換エンジン：JSONCとYAMLのセマンティックギャップの解消JSONCとYAMLは似て非なるものです。単なる構造の写像だけでなく、各フォーマットの慣習（Idiom）に合わせた変換が必要です 30。6.1 JSONCからYAMLへの変換戦略ブロックコメントの処理:YAMLはブロックコメント /*... */ を持ちません。Transformerは、CST内のBlockCommentノードを検出し、それを複数行の行コメント #... に分解・変換する必要があります。変換前: /* 複数行\nコメント */変換後: # 複数行 (改行) # コメント配置の調整: 行の途中にあるブロックコメント（例: key: /* 値 */ value）は、YAMLの構文上許されないため、直前の行（Leading）または直後の行（Trailing）に移動させる安全策をとります 2。ルートオブジェクトのアンラップ:JSONCは必ず {... } や [... ] で囲まれますが、YAMLのルートドキュメントは通常これらの括弧を省略します。変換時には最上位のコンテナの種類を確認し、YAMLのルートノードとして適切に展開します。クォートの除去（Unquoting）:JSONは全てのキーをクォートする必要がありますが、YAMLは英数字のみのキーであればクォートを省略するのが一般的です。変換ロジック: キー文字列が ^[a-zA-Z0-9_-]+$ などの正規表現にマッチする場合、YAMLノード生成時にStyle::Plain（クォートなし）を選択します。これ以外の文字を含む場合は Style::DoubleQuoted を維持します。6.2 YAMLからJSONCへの変換戦略インデントから括弧への変換:YAMLのインデント構造を解析し、JSONCの {} や `` に閉じる処理が必要です。これはスタックを用いて現在のネストレベルを管理することで実現します。アンカーとエイリアスの解決:YAMLの強力な機能であるアンカー（&anchor）とエイリアス（*anchor）は標準JSONには存在しません。戦略A（展開）: エイリアス部分に参照元の値をコピーして展開する（データサイズが増加する可能性あり）。戦略B（エラー/無視）: 厳密なJSONへの変換を目指すなら展開が必須ですが、JSONCであればコメントとして // Alias to *anchor のように情報を残す手もあります。一般的には戦略A（展開）が期待されます 8。7. 出力生成：Wadler-Lindig Pretty Printerの実装変換後のCSTを文字列化する際、単純な文字列連結ではインデントや行送りが崩れやすくなります。特にYAMLはインデントが意味を持つため、厳密なレイアウト制御が必要です。ここで、関数型言語界隈で標準的なWadler-Lindig Pretty PrinterアルゴリズムをMoonBitで実装することを推奨します 33。このアルゴリズムは、ドキュメントを「文書（Doc）」という代数的データ型で表現し、それらを結合（Concat）、ネスト（Nest）、グループ化（Group）する演算子を提供します。MoonBitにおけるDoc型定義:コード スニペットenum Doc {
  Nil
  Text(String)
  Cons(Doc, Doc)
  Nest(Int, Doc) // インデントレベルを指定
  Line           // 改行（必要に応じてスペースになる）
  Group(Doc)     // 一行に収まるなら改行せず、収まらないなら改行する
}
この抽象化により、以下のメリットが得られます。YAMLのインデント管理: Nestコンストラクタを使うことで、プロパティやリストアイテムのインデントを自動的に計算・適用できます。コメントの整列: コメントを出力する際も、現在のインデントレベルに合わせて適切にスペースを挿入できます。長い行の折り返し: JSONC出力時、配列やオブジェクトが長すぎる場合に自動的に複数行に展開するフォーマット機能を提供できます。既存のMoonBitコミュニティライブラリであるprettyprinter 36 をベースにするか、またはYAML特有の要件（コメントの位置合わせ）に合わせてカスタマイズした実装を行うのが良いでしょう。特にコメントの出力に関しては、prettierのように「直前のノードとの位置関係」を考慮して、Docツリーの中に適切に配置する必要があります 37。8. パフォーマンスとメモリ管理の最適化MoonBitは高速な実行速度を誇りますが、大規模な設定ファイル（例：数メガバイトのKubernetesマニフェストなど）を扱う場合、メモリアロケーションがボトルネックになり得ます。8.1 文字列インターニングとゼロコピーCSTの各ノードに文字列（キー、値、コメント）をそのままコピーして持たせると、メモリ使用量が増大します。String Viewの活用: ソースコード全体の文字列を一つ保持し、各ノードは「開始インデックス」と「長さ」のみを持つStringView（またはスライス）として実装することで、メモリコピーを最小限に抑える「ゼロコピー解析」が可能になります 22。注意: MoonBitのStringはUTF-16ベースであり、不変です。部分文字列の参照には標準ライブラリのサポート状況を確認しつつ、効率的なスライス操作を行う必要があります。8.2 バッファリングとStringBuilder出力処理（Emitter）においては、頻繁な小さな文字列の書き込みが発生します。MoonBitのStringBuilderを利用してバッファリングを行い、I/Oコール（ファイル書き込みなど）の回数を減らすことが必須です 22。コード スニペット// StringBuilderの使用例
let sb = StringBuilder::new()
sb.write_string("key: ")
sb.write_string(value)
sb.write_char('\n')
let result = sb.to_string()
9. テスト戦略と品質保証パーサー・コンバーターの品質保証には、以下のテスト戦略が有効です。9.1 ラウンドトリップテスト（Round-Trip Testing）「解析 → 変換 → 再解析」の結果が、元のデータと意味的に等価であることを検証します 38。JSONC -> CST -> JSONC：フォーマットやコメントが保存されているか（Idempotency test）。JSONC -> CST -> YAML -> CST -> JSONC：相互変換を行ってもデータの欠損がないか。9.2 スナップショットテストMoonBitのテスト機能にはinspect関数があり、これを用いて出力結果のスナップショットテストを行うことが推奨されます 39。コード スニペットtest "transform_with_comment" {
  let jsonc = "{ \"a\": 1 // comment \n }"
  let yaml = convert_jsonc_to_yaml(jsonc)
  // 期待されるYAML出力と比較
  inspect(yaml, content="a: 1 # comment\n") 
}
これにより、コメントの位置ずれやフォーマットの崩れを回帰テストとして検知できます。10. エコシステムへの統合と配布10.1 パッケージ管理完成したライブラリは、MoonBitのパッケージマネージャmoonを用いて管理し、mooncakes.ioレジストリに公開することでコミュニティに貢献できます 40。moon.mod.jsonの設定例:JSON{
  "name": "username/jsonc_yaml_converter",
  "version": "0.1.0",
  "readme": "README.md",
  "license": "Apache-2.0",
  "keywords": ["json", "yaml", "converter", "parser"]
}
10.2 FFIによる拡張性MoonBitの強みであるFFIを活用し、作成したライブラリをJavaScript（WebブラウザやNode.js）やC環境から呼び出せるようにインターフェースを公開します 42。これにより、例えば「ブラウザ上で動作する設定ファイル変換ツール」を、サーバーサイドの処理なしにセキュアに実装することが可能になります。11. 結論MoonBitを用いたコメント保持型のJSONC-YAML変換ライブラリの構築は、単なるテキスト置換以上の複雑なエンジニアリング課題です。しかし、MoonBitの提供するADTs、パターンマッチング、そして高性能な文字列処理能力を活用することで、堅牢かつ高速な実装が可能となります。本レポートで提案したCST中心のアーキテクチャとLeading/Trailingトリビア結合アルゴリズム、そしてWadler-Lindig Pretty Printerの組み合わせは、既存の「コメントが消える」変換ツールの問題を根底から解決するものです。このライブラリは、MoonBitエコシステムの成熟度を示す重要なユースケースとなると同時に、開発者の生産性を向上させる実用的なツールとして機能するでしょう。1
